<!DOCTYPE html>
<html>
<head>
    <title>Stochastic Policy Example: Aliased Grid World</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --light-gray: #ecf0f1;
            --medium-gray: #bdc3c7;
            --wall-color: #7f8c8d;
            --text-color: #2c3e50;
        }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: var(--text-color);
        }
        
        h1 {
            text-align: center;
            color: var(--primary-color);
        }
        
        .grid-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .policy {
            width: 280px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            grid-template-rows: repeat(2, 60px);
            gap: 3px;
            margin: 15px auto;
        }
        
        .cell {
            width: 50px;
            height: 60px;
            border: 1px solid var(--light-gray);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: white;
            border-radius: 3px;
            position: relative;
        }
        
        .cell.hidden {
            visibility: hidden;
            border: none;
        }
        
        .agent {
            background-color: var(--success-color);
            color: white;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .treasure {
            background-color: gold;
        }
        
        .aliased {
            background-color: var(--medium-gray);
        }
        
        .wall {
            background-color: var(--wall-color);
        }
        
        .arrow {
            position: absolute;
            font-size: 18px;
            color: var(--danger-color);
            font-weight: bold;
        }
        
        .right { right: 5px; }
        .left { left: 5px; }
        .down { bottom: 5px; }
        
        button {
            padding: 8px 16px;
            margin: 4px 0;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        
        .reset-btn {
            background-color: var(--danger-color);
        }
        
        .result {
            min-height: 20px;
            margin: 8px 0;
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .success {
            color: var(--success-color);
        }
        
        .failure {
            color: var(--danger-color);
        }
        
        .stuck {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { background-color: #ffcccc; }
            50% { background-color: #ff9999; }
            100% { background-color: #ffcccc; }
        }
        
        .explanation {
            background: var(--light-gray);
            padding: 15px;
            border-radius: 8px;
            margin-top: 25px;
        }
    </style>
</head>
<body>
    <h1>Stochastic Policy Example: Aliased Grid World</h1>
    
    <div class="grid-container">
        <div class="policy">
            <h3>Deterministic (‚Üí from left)</h3>
            <div class="grid" id="det-left-grid"></div>
            <button id="det-left-run">Run ‚Üí Policy</button>
            <button id="det-left-reset" class="reset-btn">Reset</button>
            <div class="result" id="det-left-result"></div>
        </div>
        
        <div class="policy">
            <h3>Deterministic (‚Üí from right)</h3>
            <div class="grid" id="det-right-grid"></div>
            <button id="det-right-run">Run ‚Üí Policy</button>
            <button id="det-right-reset" class="reset-btn">Reset</button>
            <div class="result" id="det-right-result"></div>
        </div>
        
        <div class="policy">
            <h3>Stochastic (50/50 in gray)</h3>
            <div class="grid" id="sto-grid"></div>
            <button id="sto-run">Run Stochastic Policy</button>
            <button id="sto-reset" class="reset-btn">Reset</button>
            <div class="result" id="sto-result"></div>
        </div>
    </div>
    
<div class="explanation">
  <h3>Policy Behavior</h3>

  <h4>Deterministic Policies:</h4>
  <p>
    In aliased (gray) states, optimal deterministic policies must choose consistent actions:<br>
    üî∏ Always move left in both gray states (‚Üê ‚Üê)<br>
    üî∏ Always move right in both gray states (‚Üí ‚Üí)<br>
    This consistency can lead to suboptimal behavior when starting from certain positions.
  </p>

  <h4>Stochastic Policies:</h4>
  <p>
    Optimal solution: Randomize actions in aliased states<br>
    üîπ œÄ(right | walls above/below) = 0.5<br>
    üîπ œÄ(left | walls above/below) = 0.5
  </p>
</div>


    <script>
        // Custom grid configuration
        const gridConfig = [
            // Top row (row 0)
            ['S', 'A', 'M', 'A', 'S'],
            // Bottom row (row 1)
            ['w', 'X', 'T', 'X', 'w']
        ];
        
        // Game states
        const states = {
            'det-left': { 
                pos: [0, 0], // Start at left white block
                running: false, 
                policy: 'right',
                resultEl: document.getElementById('det-left-result')
            },
            'det-right': { 
                pos: [0, 4], // Start at right white block
                running: false, 
                policy: 'right',
                resultEl: document.getElementById('det-right-result')
            },
            'sto': { 
                pos: [0, 0], // Start at left white block
                running: false,
                resultEl: document.getElementById('sto-result')
            }
        };
        
        function cellExists(row, col) {
            return gridConfig[row][col] !== 'X';
        }
        
        function isWall(row, col) {
            return gridConfig[row][col] === 'w';
        }
        
        function isAliased(row, col) {
            return gridConfig[row][col] === 'A';
        }
        
        function isMiddle(row, col) {
            return gridConfig[row][col] === 'M';
        }
        
        function isStart(row, col) {
            return gridConfig[row][col] === 'S';
        }
        
        function isTreasure(row, col) {
            return gridConfig[row][col] === 'T';
        }
        
        function renderGrids() {
            renderGrid('det-left-grid', states['det-left'].pos, 'right');
            renderGrid('det-right-grid', states['det-right'].pos, 'right');
            renderGrid('sto-grid', states['sto'].pos, 'stochastic');
        }
        
        function renderGrid(gridId, agentPos, policy = null) {
            const gridElement = document.getElementById(gridId);
            gridElement.innerHTML = '';
            
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    if (!cellExists(row, col)) {
                        cell.classList.add('hidden');
                        gridElement.appendChild(cell);
                        continue;
                    }
                    
                    if (isTreasure(row, col)) {
                        cell.className += ' treasure';
                        cell.textContent = 'üí∞';
                    } else if (isAliased(row, col)) {
                        cell.className += ' aliased';
                        if (policy === 'right') {
                            const arrow = document.createElement('div');
                            arrow.className = `arrow right`;
                            arrow.textContent = '‚Üí';
                            cell.appendChild(arrow);
                        } else if (policy === 'stochastic') {
                            const arrow1 = document.createElement('div');
                            arrow1.className = `arrow left`;
                            arrow1.textContent = '‚Üê';
                            cell.appendChild(arrow1);
                            
                            const arrow2 = document.createElement('div');
                            arrow2.className = `arrow right`;
                            arrow2.textContent = '‚Üí';
                            cell.appendChild(arrow2);
                        }
                    } else if (isMiddle(row, col)) {
                        const arrow = document.createElement('div');
                        arrow.className = `arrow down`;
                        arrow.textContent = '‚Üì';
                        cell.appendChild(arrow);
                    } else if (isWall(row, col)) {
                        cell.className += ' wall';
                    } else if (isStart(row, col)) {
                        // White block - no special styling
                    }
                    
                    gridElement.appendChild(cell);
                }
            }
            
            updateAgentPosition(gridId, agentPos);
        }
        
        function updateAgentPosition(gridId, pos) {
            document.querySelectorAll(`#${gridId} .agent`).forEach(el => el.remove());
            
            const [row, col] = pos;
            const cells = document.querySelectorAll(`#${gridId} .cell:not(.hidden)`);
            
            let index = 0;
            for (let r = 0; r < 2; r++) {
                for (let c = 0; c < 5; c++) {
                    if (!cellExists(r, c)) continue;
                    if (r === row && c === col) {
                        const agent = document.createElement('div');
                        agent.className = 'agent';
                        agent.textContent = 'ü§ñ';
                        cells[index].appendChild(agent);
                        
                        const stateKey = gridId.replace('-grid', '');
                        if (states[stateKey]?.stuck) {
                            cells[index].classList.add('stuck');
                        }
                        return;
                    }
                    index++;
                }
            }
        }
        
        function moveAgent(type) {
            const state = states[type];
            if (!state.running) return;
            
            const [row, col] = state.pos;
            
            if (isTreasure(row, col)) {
                state.resultEl.textContent = "‚úÖ Found treasure!";
                state.resultEl.className = "result success";
                state.running = false;
                return;
            }
            
            const moves = [];
            
            if (col < 4 && cellExists(row, col + 1) && !isWall(row, col + 1)) {
                moves.push([0, 1]);
            }
            if (col > 0 && cellExists(row, col - 1) && !isWall(row, col - 1)) {
                moves.push([0, -1]);
            }
            if (row === 0 && cellExists(1, col) && !isWall(1, col)) {
                moves.push([1, 0]);
            }
            if (row === 1 && cellExists(0, col) && !isWall(0, col)) {
                moves.push([-1, 0]);
            }
            
            if (moves.length > 0) {
                let move;
                
                if (isMiddle(row, col)) {
                    // Always move down from middle
                    move = moves.find(m => m[0] === 1) || moves[0];
                }
                else if (isAliased(row, col)) {
                    if (type === 'det-left' || type === 'det-right') {
                        // Always prefer right in aliased states
                        move = moves.find(m => m[1] === 1) || moves[0];
                    } else {
                        // Stochastic policy
                        const possibleMoves = moves.filter(m => m[1] !== 0);
                        if (possibleMoves.length > 0) {
                            move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        } else {
                            move = moves[Math.floor(Math.random() * moves.length)];
                        }
                    }
                } else {
                    if (type === 'det-left' || type === 'det-right') {
                        // Prefer right, then down, then left
                        move = moves.find(m => m[1] === 1) || 
                               moves.find(m => m[0] === 1) || 
                               moves.find(m => m[1] === -1) || 
                               moves[0];
                    } else {
                        // Stochastic policy
                        move = moves[Math.floor(Math.random() * moves.length)];
                    }
                }
                
                const [dr, dc] = move;
                state.pos = [row + dr, col + dc];
                
                if ((type === 'det-left' || type === 'det-right') && isAliased(row, col)) {
                    const [newRow, newCol] = state.pos;
                    if (isAliased(newRow, newCol) && type === 'det-right') {
                        // Only the right-starting agent gets stuck
                        state.stuck = true;
                        state.resultEl.textContent = "‚ùå Stuck in aliased loop!";
                        state.resultEl.className = "result failure";
                        state.running = false;
                    }
                }
                
                updateAgentPosition(`${type}-grid`, state.pos);
            }
            
            if (state.running) {
                setTimeout(() => moveAgent(type), 600);
            }
        }
        
        function resetAgent(type) {
            const state = states[type];
            // Reset to starting positions
            if (type === 'det-right') state.pos = [0, 4];
            else if (type === 'det-left') state.pos = [0, 0];
            else state.pos = [0, 0];
            state.running = false;
            state.stuck = false;
            state.resultEl.textContent = "";
            state.resultEl.className = "result";
            updateAgentPosition(`${type}-grid`, state.pos);
        }
        
        function init() {
            renderGrids();
            
            document.getElementById('det-left-run').addEventListener('click', () => {
                if (!states['det-left'].running) {
                    resetAgent('det-left');
                    states['det-left'].running = true;
                    moveAgent('det-left');
                }
            });
            
            document.getElementById('det-right-run').addEventListener('click', () => {
                if (!states['det-right'].running) {
                    resetAgent('det-right');
                    states['det-right'].running = true;
                    moveAgent('det-right');
                }
            });
            
            document.getElementById('sto-run').addEventListener('click', () => {
                if (!states['sto'].running) {
                    resetAgent('sto');
                    states['sto'].running = true;
                    moveAgent('sto');
                }
            });
            
            document.getElementById('det-left-reset').addEventListener('click', () => {
                resetAgent('det-left');
            });
            
            document.getElementById('det-right-reset').addEventListener('click', () => {
                resetAgent('det-right');
            });
            
            document.getElementById('sto-reset').addEventListener('click', () => {
                resetAgent('sto');
            });
        }
        
        init();
    </script>
</body>
</html>
