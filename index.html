<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic Policy Example: Aliased Grid World</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes pulse {
            0% { background-color: #fee2e2; }
            50% { background-color: #fca5a5; }
            100% { background-color: #fee2e2; }
        }
        .stuck {
            animation: pulse 1.5s infinite;
        }
        .agent-move {
            transition: all 0.5s ease-in-out;
        }
        .policy-card {
            transition: all 0.3s ease;
        }
        .policy-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        }
        .grid-cell {
            transition: background-color 0.3s ease;
        }
        .bad-goal {
            background-color: #ef4444;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-indigo-800 mb-3">Stochastic Policy in Aliased Grid World</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">
                Explore how stochastic policies can solve problems that deterministic policies struggle with in partially observable environments.
            </p>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Policy Cards Container -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-12">
                <!-- Deterministic (Left) Policy -->
                <div class="policy-card bg-white rounded-xl shadow-lg overflow-hidden border border-gray-100">
                    <div class="p-6">
                        <div class="flex items-center mb-4">
                            <div class="bg-blue-100 p-2 rounded-lg mr-3">
                                <i class="fas fa-arrow-right text-blue-600 text-xl"></i>
                            </div>
                            <h3 class="text-xl font-semibold text-gray-800">Deterministic (→ from left)</h3>
                        </div>
                        
                        <div class="grid grid-cols-5 gap-1 mb-6 mx-auto w-fit">
                            <!-- Grid will be rendered here by JavaScript -->
                        </div>
                        
                        <div class="flex space-x-3 mb-4">
                            <button class="run-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex-1 transition flex items-center justify-center">
                                <i class="fas fa-play mr-2"></i> Run Policy
                            </button>
                            <button class="reset-btn bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-lg transition">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                        
                        <div class="result text-center py-2 rounded-lg mb-4"></div>
                        
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <p class="text-sm text-gray-700">
                                <i class="fas fa-info-circle text-blue-500 mr-1"></i> 
                                In aliased (gray) states, this deterministic policy always moves right (→ →).
                                Works well when starting from the left, but would get stuck if starting from the right.
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Deterministic (Right) Policy -->
                <div class="policy-card bg-white rounded-xl shadow-lg overflow-hidden border border-gray-100">
                    <div class="p-6">
                        <div class="flex items-center mb-4">
                            <div class="bg-red-100 p-2 rounded-lg mr-3">
                                <i class="fas fa-arrow-right text-red-600 text-xl"></i>
                            </div>
                            <h3 class="text-xl font-semibold text-gray-800">Deterministic (→ from right)</h3>
                        </div>
                        
                        <div class="grid grid-cols-5 gap-1 mb-6 mx-auto w-fit">
                            <!-- Grid will be rendered here by JavaScript -->
                        </div>
                        
                        <div class="flex space-x-3 mb-4">
                            <button class="run-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex-1 transition flex items-center justify-center">
                                <i class="fas fa-play mr-2"></i> Run Policy
                            </button>
                            <button class="reset-btn bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-lg transition">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                        
                        <div class="result text-center py-2 rounded-lg mb-4"></div>
                        
                        <div class="bg-red-50 p-4 rounded-lg">
                            <p class="text-sm text-gray-700">
                                <i class="fas fa-info-circle text-red-500 mr-1"></i> 
                                In aliased (gray) states, this deterministic policy always moves right (→ →).
                                Gets stuck in an aliased loop when starting from the right position.
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Stochastic Policy -->
                <div class="policy-card bg-white rounded-xl shadow-lg overflow-hidden border border-gray-100">
                    <div class="p-6">
                        <div class="flex items-center mb-4">
                            <div class="bg-purple-100 p-2 rounded-lg mr-3">
                                <i class="fas fa-random text-purple-600 text-xl"></i>
                            </div>
                            <h3 class="text-xl font-semibold text-gray-800">Stochastic (50/50 in gray)</h3>
                        </div>
                        
                        <div class="grid grid-cols-5 gap-1 mb-6 mx-auto w-fit">
                            <!-- Grid will be rendered here by JavaScript -->
                        </div>
                        
                        <div class="flex space-x-3 mb-4">
                            <button class="run-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex-1 transition flex items-center justify-center">
                                <i class="fas fa-play mr-2"></i> Run Policy
                            </button>
                            <button class="reset-btn bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-lg transition">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                        
                        <div class="result text-center py-2 rounded-lg mb-4"></div>
                        
                        <div class="bg-purple-50 p-4 rounded-lg">
                            <p class="text-sm text-gray-700 mb-2">
                                <i class="fas fa-info-circle text-purple-500 mr-1"></i> 
                                Optimal solution: Randomizes actions in aliased states.
                            </p>
                            <ul class="text-xs space-y-1">
                                <li class="flex items-start">
                                    <i class="fas fa-dot-circle text-purple-400 mt-1 mr-2 text-xs"></i>
                                    <span>π(right | walls above/below) = 0.5</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fas fa-dot-circle text-purple-400 mt-1 mr-2 text-xs"></i>
                                    <span>π(left | walls above/below) = 0.5</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fas fa-dot-circle text-purple-400 mt-1 mr-2 text-xs"></i>
                                    <span>Avoids getting stuck and eventually reaches the treasure.</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Explanation Section -->
            <div class="bg-white rounded-xl shadow-md p-6 mb-8 border border-gray-100">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-lightbulb text-yellow-500 mr-3"></i>
                    Understanding the Problem
                </h2>
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2 flex items-center">
                            <i class="fas fa-question-circle text-blue-500 mr-2"></i>
                            What is an Aliased State?
                        </h3>
                        <p class="text-gray-600 text-sm">
                            Aliased states are perceptually identical states that require different optimal actions.
                            In this grid world, the gray cells are aliased - they look the same to the agent but require
                            different movements to reach the treasure depending on their actual position.
                        </p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-700 mb-2 flex items-center">
                            <i class="fas fa-chart-line text-green-500 mr-2"></i>
                            Why Stochastic Policies Work
                        </h3>
                        <p class="text-gray-600 text-sm">
                            Deterministic policies can get stuck in infinite loops in aliased environments.
                            By introducing randomness (stochastic policy), the agent can eventually escape
                            these loops and find the optimal path to the treasure.
                        </p>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="text-center text-gray-500 text-sm mt-12">
            <p>Interactive demonstration of stochastic policies in reinforcement learning</p>
            <p class="mt-1">Try running each policy multiple times to observe the differences!</p>
        </footer>
    </div>

    <script>
        // Custom grid configuration
        const gridConfig = [
            // Top row (row 0)
            ['S', 'A', 'M', 'A', 'S'],
            // Bottom row (row 1)
            ['B', '', 'T', '', 'B']  // B = Bad goal, '' = completely empty space
        ];
        
        // Policy types
        const POLICY_TYPES = {
            DET_LEFT: 'det-left',
            DET_RIGHT: 'det-right',
            STOCHASTIC: 'stochastic'
        };
        
        // Game states
        const states = {
            [POLICY_TYPES.DET_LEFT]: { 
                pos: [0, 0], // Start at left white block
                running: false, 
                policy: 'right',
                gridElement: document.querySelectorAll('.policy-card')[0].querySelector('.grid'),
                resultEl: document.querySelectorAll('.policy-card')[0].querySelector('.result'),
                runBtn: document.querySelectorAll('.policy-card')[0].querySelector('.run-btn'),
                resetBtn: document.querySelectorAll('.policy-card')[0].querySelector('.reset-btn')
            },
            [POLICY_TYPES.DET_RIGHT]: { 
                pos: [0, 4], // Start at right white block
                running: false, 
                policy: 'right',
                gridElement: document.querySelectorAll('.policy-card')[1].querySelector('.grid'),
                resultEl: document.querySelectorAll('.policy-card')[1].querySelector('.result'),
                runBtn: document.querySelectorAll('.policy-card')[1].querySelector('.run-btn'),
                resetBtn: document.querySelectorAll('.policy-card')[1].querySelector('.reset-btn')
            },
            [POLICY_TYPES.STOCHASTIC]: { 
                pos: [0, 0], // Start at left white block
                running: false,
                gridElement: document.querySelectorAll('.policy-card')[2].querySelector('.grid'),
                resultEl: document.querySelectorAll('.policy-card')[2].querySelector('.result'),
                runBtn: document.querySelectorAll('.policy-card')[2].querySelector('.run-btn'),
                resetBtn: document.querySelectorAll('.policy-card')[2].querySelector('.reset-btn')
            }
        };
        
        function cellExists(row, col) {
            const val = gridConfig[row][col];
            return val !== 'X' && val !== undefined;
        }
        
        function isBadGoal(row, col) {
            return gridConfig[row][col] === 'B';
        }
        
        function isAliased(row, col) {
            return gridConfig[row][col] === 'A';
        }
        
        function isMiddle(row, col) {
            return gridConfig[row][col] === 'M';
        }
        
        function isStart(row, col) {
            return gridConfig[row][col] === 'S';
        }
        
        function isTreasure(row, col) {
            return gridConfig[row][col] === 'T';
        }
        
        function renderGrids() {
            Object.keys(states).forEach(type => {
                renderGrid(type);
            });
        }
        
        function renderGrid(type) {
            const state = states[type];
            state.gridElement.innerHTML = '';
            
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 5; col++) {
                    if (!cellExists(row, col)) continue;
                    
                    const cell = document.createElement('div');
                    // Hide completely empty cells (empty string in config)
                    const isEmpty = gridConfig[row][col] === '';
                    cell.className = `grid-cell w-12 h-14 ${isEmpty ? 'invisible' : 'border border-gray-200 rounded flex items-center justify-center relative'}`;
                    
                    if (isTreasure(row, col)) {
                        cell.className += ' bg-yellow-100';
                        cell.innerHTML = '<i class="fas fa-gem text-yellow-500 text-xl"></i>';
                    } else if (isAliased(row, col)) {
                        cell.className += ' bg-gray-200';
                        
                        if (type === POLICY_TYPES.DET_LEFT || type === POLICY_TYPES.DET_RIGHT) {
                            cell.innerHTML += '<i class="fas fa-arrow-right text-red-500 absolute right-1"></i>';
                        } else {
                            cell.innerHTML += `
                                <i class="fas fa-arrow-left text-purple-500 absolute left-1"></i>
                                <i class="fas fa-arrow-right text-purple-500 absolute right-1"></i>
                            `;
                        }
                    } else if (isMiddle(row, col)) {
                        cell.innerHTML += '<i class="fas fa-arrow-down text-blue-500 absolute bottom-1"></i>';
                    } else if (isBadGoal(row, col)) {
                        cell.className += ' bad-goal';
                        cell.innerHTML = '<i class="fas fa-skull text-white text-xl"></i>';
                        cell.title = "Bad goal state - avoid!";
                    } else if (isStart(row, col)) {
                        cell.className += ' bg-white';
                    }
                    
                    state.gridElement.appendChild(cell);
                }
            }
            
            updateAgentPosition(type);
        }
        
        function updateAgentPosition(type) {
            const state = states[type];
            // Remove any existing agent
            state.gridElement.querySelectorAll('.agent').forEach(el => el.remove());
            // Remove stuck class from all cells
            state.gridElement.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('stuck');
            });
            
            const [row, col] = state.pos;
            const cells = state.gridElement.querySelectorAll('.grid-cell');
            
            let index = 0;
            for (let r = 0; r < 2; r++) {
                for (let c = 0; c < 5; c++) {
                    if (!cellExists(r, c)) continue;
                    if (r === row && c === col) {
                        const agent = document.createElement('div');
                        agent.className = 'agent absolute w-9 h-9 bg-green-500 text-white rounded-full flex items-center justify-center text-lg agent-move';
                        agent.innerHTML = '<i class="fas fa-robot"></i>';
                        cells[index].appendChild(agent);
                        cells[index].classList.add('relative');
                        
                        if (state.stuck) {
                            cells[index].classList.add('stuck');
                        }
                        return;
                    }
                    index++;
                }
            }
        }
        
        function moveAgent(type) {
            const state = states[type];
            if (!state.running) return;
            
            const [row, col] = state.pos;
            
            if (isTreasure(row, col)) {
                state.resultEl.innerHTML = '<span class="text-green-600"><i class="fas fa-check-circle mr-1"></i> Found treasure!</span>';
                state.resultEl.className = "result bg-green-50 py-2 rounded-lg mb-4";
                state.running = false;
                state.runBtn.innerHTML = '<i class="fas fa-play mr-2"></i> Run Policy';
                state.runBtn.classList.remove('bg-blue-700');
                state.runBtn.classList.add('bg-blue-600');
                return;
            }
            
            if (isBadGoal(row, col)) {
                state.resultEl.innerHTML = '<span class="text-red-600"><i class="fas fa-skull mr-1"></i> Hit bad goal state!</span>';
                state.resultEl.className = "result bg-red-50 py-2 rounded-lg mb-4";
                state.running = false;
                state.runBtn.innerHTML = '<i class="fas fa-play mr-2"></i> Run Policy';
                state.runBtn.classList.remove('bg-blue-700');
                state.runBtn.classList.add('bg-blue-600');
                return;
            }
            
            const moves = [];
            
            if (col < 4 && cellExists(row, col + 1) && !isBadGoal(row, col + 1)) {
                moves.push([0, 1]);
            }
            if (col > 0 && cellExists(row, col - 1) && !isBadGoal(row, col - 1)) {
                moves.push([0, -1]);
            }
            if (row === 0 && cellExists(1, col) && !isBadGoal(1, col)) {
                moves.push([1, 0]);
            }
            if (row === 1 && cellExists(0, col) && !isBadGoal(0, col)) {
                moves.push([-1, 0]);
            }
            
            if (moves.length > 0) {
                let move;
                
                if (isMiddle(row, col)) {
                    // Always move down from middle
                    move = moves.find(m => m[0] === 1) || moves[0];
                }
                else if (isAliased(row, col)) {
                    if (type === POLICY_TYPES.DET_LEFT || type === POLICY_TYPES.DET_RIGHT) {
                        // Always prefer right in aliased states
                        move = moves.find(m => m[1] === 1) || moves[0];
                    } else {
                        // Stochastic policy
                        const possibleMoves = moves.filter(m => m[1] !== 0);
                        if (possibleMoves.length > 0) {
                            move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        } else {
                            move = moves[Math.floor(Math.random() * moves.length)];
                        }
                    }
                } else {
                    if (type === POLICY_TYPES.DET_LEFT || type === POLICY_TYPES.DET_RIGHT) {
                        // Prefer right, then down, then left
                        move = moves.find(m => m[1] === 1) || 
                               moves.find(m => m[0] === 1) || 
                               moves.find(m => m[1] === -1) || 
                               moves[0];
                    } else {
                        // Stochastic policy
                        move = moves[Math.floor(Math.random() * moves.length)];
                    }
                }
                
                const [dr, dc] = move;
                state.pos = [row + dr, col + dc];
                
                if ((type === POLICY_TYPES.DET_LEFT || type === POLICY_TYPES.DET_RIGHT) && isAliased(row, col)) {
                    const [newRow, newCol] = state.pos;
                    if (isAliased(newRow, newCol) && type === POLICY_TYPES.DET_RIGHT) {
                        // Only the right-starting agent gets stuck
                        state.stuck = true;
                        state.resultEl.innerHTML = '<span class="text-red-600"><i class="fas fa-exclamation-circle mr-1"></i> Stuck in aliased loop!</span>';
                        state.resultEl.className = "result bg-red-50 py-2 rounded-lg mb-4";
                        state.running = false;
                        state.runBtn.innerHTML = '<i class="fas fa-play mr-2"></i> Run Policy';
                        state.runBtn.classList.remove('bg-blue-700');
                        state.runBtn.classList.add('bg-blue-600');
                    }
                }
                
                updateAgentPosition(type);
            }
            
            if (state.running) {
                setTimeout(() => moveAgent(type), 600);
            }
        }
        
        function resetAgent(type) {
            const state = states[type];
            // Reset to starting positions
            if (type === POLICY_TYPES.DET_RIGHT) state.pos = [0, 4];
            else if (type === POLICY_TYPES.DET_LEFT) state.pos = [0, 0];
            else state.pos = [0, 0];
            state.running = false;
            state.stuck = false;
            state.resultEl.innerHTML = "";
            state.resultEl.className = "result py-2 rounded-lg mb-4";
            state.runBtn.innerHTML = '<i class="fas fa-play mr-2"></i> Run Policy';
            state.runBtn.classList.remove('bg-blue-700');
            state.runBtn.classList.add('bg-blue-600');
            updateAgentPosition(type);
        }
        
        function init() {
            renderGrids();
            
            // Set up event listeners for each policy type
            Object.keys(states).forEach(type => {
                const state = states[type];
                
                state.runBtn.addEventListener('click', () => {
                    if (!state.running) {
                        resetAgent(type);
                        state.running = true;
                        state.runBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Running...';
                        state.runBtn.classList.remove('bg-blue-600');
                        state.runBtn.classList.add('bg-blue-700');
                        moveAgent(type);
                    }
                });
                
                state.resetBtn.addEventListener('click', () => {
                    resetAgent(type);
                });
            });
        }
        
        init();
    </script>
</body>
</html>
